// न्यूनतम बाइटकोड उत्पादक: केवल 'लिख("…")' कथन समर्थित
आयात कण्ठि.शब्दविभाजक
आयात कण्ठि.वाक्यविच्छेदक

संरचना लेखन {
  कोड: सूची<अष्टक>
}

कार्य आरम्भ_लेखन(): लेखन { लौटय लेखन{कोड: []} }

कार्य लिख_बाइट(ल:&लेखन, ब: अष्टक): शून्य { जोड़ो(ल.कोड, ब) }

कार्य लिख_u32(ल:&लेखन, व: पूर्ण64): शून्य {
  लिख_बाइट(ल, (व      ) & 0xFF)
  लिख_बाइट(ल, (व >> 8 ) & 0xFF)
  लिख_बाइट(ल, (व >> 16) & 0xFF)
  लिख_बाइट(ल, (व >> 24) & 0xFF)
}

कार्य लिख_i64(ल:&लेखन, व: पूर्ण64): शून्य {
  // लिटिल-एंडियन
  लिख_बाइट(ल, (व      ) & 0xFF)
  लिख_बाइट(ल, (व >> 8 ) & 0xFF)
  लिख_बाइट(ल, (व >> 16) & 0xFF)
  लिख_बाइट(ल, (व >> 24) & 0xFF)
  लिख_बाइट(ल, (व >> 32) & 0xFF)
  लिख_बाइट(ल, (व >> 40) & 0xFF)
  लिख_बाइट(ल, (व >> 48) & 0xFF)
  लिख_बाइट(ल, (व >> 56) & 0xFF)
}

कार्य लिख_i32(ल:&लेखन, व: पूर्ण64): शून्य {
  लिख_बाइट(ल, (व      ) & 0xFF)
  लिख_बाइट(ल, (व >> 8 ) & 0xFF)
  लिख_बाइट(ल, (व >> 16) & 0xFF)
  लिख_बाइट(ल, (व >> 24) & 0xFF)
}

कार्य स्थान(ल:&लेखन): पूर्ण64 { लौटय दीर्घता(ल.कोड) }

कार्य पैच_i32(ल:&लेखन, सू: पूर्ण64, व: पूर्ण64): शून्य {
  ल.कोड[सू+0] = (व      ) & 0xFF
  ल.कोड[सू+1] = (व >> 8 ) & 0xFF
  ल.कोड[सू+2] = (व >> 16) & 0xFF
  ल.कोड[सू+3] = (व >> 24) & 0xFF
}

कार्य लेख्य_आदेश(ल:&लेखन, स: श्रृंखला): शून्य {
  // PUSH_S len + bytes ; PRINT
  लिख_बाइट(ल, 0x12)
  लिख_u32(ल, दीर्घता_बाइट(s))
  सू = 0
  जबतक (सू < दीर्घता_बाइट(s)) { लिख_बाइट(ल, बाइट_पर(s, सू)); सू = सू + 1 }
  लिख_बाइट(ल, 0x30)
}

कार्य पूर्ण_आदेश(ल:&लेखन, व: पूर्ण64): शून्य {
  लिख_बाइट(ल, 0x10)
  लिख_i64(ल, व)
}

कार्य कार्यक्रम_से_कोड(स्रोत: श्रृंखला): सूची<अष्टक> {
  प = आरम्भ_पार्सर(स्रोत)
  ल = आरम्भ_लेखन()
  // प्रतीक-सारिणी: डेमो हेतु नाम→ID (स्थानीय, क्रमिक)
  नाम_आईडी: मानचित्र<श्रृंखला, पूर्ण64> = {}
  अगला_आईडी: पूर्ण64 = 1
  कार्य दे_आईडी(न: श्रृंखला): पूर्ण64 {
    यदि (न in नाम_आईडी) { लौटय नाम_आईडी[न] }
    नाम_आईडी[न] = अगला_आईडी
    अगला_आईडी = अगला_आईडी + 1
    लौटय नाम_आईडी[न]
  }
  // कार्य पते
  कार्य_पते: मानचित्र<श्रृंखला, पूर्ण64> = {}
  कॉल_फिक्स: सूची<जोडा<पूर्ण64, श्रृंखला>> = [] // (स्थान, नाम)

  // आयात कथनों को पहले संसाधित करें
  जबतक (प.वर्तमान.प्रकार != शब्द_समाप्त) {
    // स्थापय x, ५ ।  → PUSH 5 ; STORE_S id(x)
    यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "स्थापय") {
      अग्रगामी(&प)
      यदि (प.वर्तमान.प्रकार == परिचायक) { नाम = प.वर्तमान.पाठ्य; अग्रगामी(&प) }
      यदि (प.वर्तमान.प्रकार == अल्पविराम) { अग्रगामी(&प) }
      यदि (प.वर्तमान.प्रकार == पूर्णांक) {
        मान = प.वर्तमान.पाठ्य_संख्या
        अग्रगामी(&प)
        यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
        पूर्ण_आदेश(&ल, मान)
        लिख_बाइट(&ल, 0x70)
        आई = दे_आईडी(नाम)
        लिख_i32(&ल, आई)
        जारी
      }
    }
    यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "आयात") {
      अग्रगामी(&प)
      यदि (प.वर्तमान.प्रकार == लेख्य) { मॉड्यूलनाम = प.वर्तमान.पाठ्य; अग्रगामी(&प) }
      यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
      लेख्य_आदेश(&ल, मॉड्यूलनाम)
      लिख_बाइट(&ल, 0xC0) // IMPORT
      जारी
    }
    अग्रगामी(&प)
  }
  // पार्सर को फिर से आरंभ करें
  प = आरम्भ_पार्सर(स्रोत)

  // प्रविष्टि: CALL मुख्य ; HALT (पता बाद में भरेंगे)
  लिख_बाइट(&ल, 0x80) // CALL
  मुख्य_कॉल_ऑफ = स्थान(&ल)
  लिख_i32(&ल, 0)     // placeholder
  लिख_बाइट(&ल, 0x01) // HALT
  // केवल मुख्य शरीर को स्कैन कर मुद्रण कथनों को आउटपुट करें (न्यूनतम)
  // सरलीकरण: स्रोत में "लिख(\"…\");" पंक्ति मान लेते हैं
  जबतक (प.वर्तमान.प्रकार != शब्द_समाप्त) {
    // सूची लिटरल: [ a, b, c ]  → emit each; ARR_NEW count
    यदि (प.वर्तमान.प्रकार == सूची_खुली) {
      अग्रगामी(&प)
      गणना = 0
      // पढ़ें तत्व (यहाँ केवल लेख्य या पूर्णांक सरलता से)
      जबकि (प.वर्तमान.प्रकार != सूची_बन्द और प.वर्तमान.प्रकार != शब्द_समाप्त) {
        यदि (प.वर्तमान.प्रकार == लेख्य) { लेख्य_आदेश(&ल, प.वर्तमान.पाठ्य); गणना = गणना + 1; अग्रगामी(&प) }
        अन्यथा यदि (प.वर्तमान.प्रकार == पूर्णांक) { पूर्ण_आदेश(&ल, प.वर्तमान.पाठ्य_संख्या); गणना = गणना + 1; अग्रगामी(&प) }
        यदि (प.वर्तमान.प्रकार == विराम || प.वर्तमान.प्रकार == जोड़) { अग्रगामी(&प) } // ',' treated as '+' placeholder if defined later
        यदि (प.वर्तमान.प्रकार == ',') { अग्रगामी(&प) }
      }
      अपेक्षित(&प, सूची_बन्द)
      लिख_बाइट(&ल, 0x90)
      लिख_i32(&ल, गणना)
      // यदि ';' तो प्रिंट करें (डेमो)
      यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प); लिख_बाइट(&ल, 0x30) }
      जारी
    }

    // अभिगम: नाम '[' expr ']'  → LOAD_S id(name); <expr>; ARR_GET; PRINT (यदि ';')
    यदि (प.वर्तमान.प्रकार == परिचायक और अग्रम्(&प.धारा) == '[') {
      नाम = प.वर्तमान.पाठ्य; अग्रगामी(&प)
      अपेक्षित(&प, सूची_खुली)
      यदि (प.वर्तमान.प्रकार == पूर्णांक) { पूर्ण_आदेश(&ल, प.वर्तमान.पाठ्य_संख्या); अग्रगामी(&प) }
      अपेक्षित(&प, सूची_बन्द)
      लिख_बाइट(&ल, 0x71); आई = दे_आईडी(नाम); लिख_i32(&ल, आई)
      लिख_बाइट(&ल, 0x92)
      यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प); लिख_बाइट(&ल, 0x30) }
      जारी
    }

    // मानचित्र लिटरल: { "k":"v", ... }
    यदि (प.वर्तमान.प्रकार == आकृति_खुली) {
      अग्रगामी(&प)
      गणना = 0
      जबकि (प.वर्तमान.प्रकार != आकृति_बन्द और प.वर्तमान.प्रकार != शब्द_समाप्त) {
        यदि (प.वर्तमान.प्रकार == लेख्य) { कु = प.वर्तमान.पाठ्य; अग्रगामी(&प); यदि (प.वर्तमान.प्रकार == द्विबिन्दु) { अग्रगामी(&प) } ;
          यदि (प.वर्तमान.प्रकार == लेख्य) { लेख्य_आदेश(&ल, प.वर्तमान.पाठ्य); अग्रगामी(&प) } अन्यथा यदि (प.वर्तमान.प्रकार == पूर्णांक) { पूर्ण_आदेश(&ल, प.वर्तमान.पाठ्य_संख्या); अग्रगामी(&प) }
          लेख्य_आदेश(&ल, कु); गणना = गणना + 1
          यदि (प.वर्तमान.प्रकार == अल्पविराम) { अग्रगामी(&प) }
        } अन्यथा { अग्रगामी(&प) }
      }
      अपेक्षित(&प, आकृति_बन्द)
      लिख_बाइट(&ल, 0xA0)
      लिख_i32(&ल, गणना)
      यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प); लिख_बाइट(&ल, 0x30) }
      जारी
    }

    // फाइल I/O: पढ़ो("फाइल.सं") ; लिखो("फाइल.सं", "सामग्री") ;
    यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "पढ़ो") {
      अग्रगामी(&प)
      अपेक्षित(&प, चिह्न_खुला)
      यदि (प.वर्तमान.प्रकार == लेख्य) { फाइलनाम = प.वर्तमान.पाठ्य; अग्रगामी(&प) }
      अपेक्षित(&प, चिह्न_बन्द)
      यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
      लेख्य_आदेश(&ल, फाइलनाम)
      लिख_बाइट(&ल, 0xB0) // FILE_READ
      लिख_बाइट(&ल, 0x30) // PRINT
      जारी
    }
    यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "लिखो") {
      अग्रगामी(&प)
      अपेक्षित(&प, चिह्न_खुला)
      यदि (प.वर्तमान.प्रकार == लेख्य) { फाइलनाम = प.वर्तमान.पाठ्य; अग्रगामी(&प) }
      यदि (प.वर्तमान.प्रकार == अल्पविराम) { अग्रगामी(&प) }
      यदि (प.वर्तमान.प्रकार == लेख्य) { सामग्री = प.वर्तमान.पाठ्य; अग्रगामी(&प) }
      अपेक्षित(&प, चिह्न_बन्द)
      यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
      लेख्य_आदेश(&ल, सामग्री)
      लेख्य_आदेश(&ल, फाइलनाम)
      लिख_बाइट(&ल, 0xB1) // FILE_WRITE
      जारी
    }
    यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "लिख") {
      अग्रगामी(&प)
      अपेक्षित(&प, चिह्न_खुला)
      // केवल लेख्य
      यदि (प.वर्तमान.प्रकार == लेख्य) {
        लेख = प.वर्तमान.पाठ्य
        अग्रगामी(&प)
        अपेक्षित(&प, चिह्न_बन्द)
        यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
        लेख्य_आदेश(&ल, लेख)
      } अन्यथा {
        // न्यूनतम: अन्य प्रकार अनदेखे
        अग्रगामी(&प)
      }
      जारी
    }
    // आह्वान: foo() ;  → CALL addr(foo)
    यदि (प.वर्तमान.प्रकार == परिचायक और अग्रम्(&प.धारा) == '(') {
      नाम = प.वर्तमान.पाठ्य
      अग्रगामी(&प) // नाम
      अपेक्षित(&प, चिह्न_खुला)
      अपेक्षित(&प, चिह्न_बन्द)
      यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
      लिख_बाइट(&ल, 0x80) // CALL
      // address
      addr = 0
      यदि (नाम in कार्य_पते) { addr = कार्य_पते[नाम] } अन्यथा { जोड़ो(कॉल_फिक्स, (स्थान(&ल), नाम)) }
      लिख_i32(&ल, addr)
      जारी
    }

    // असाइन: x = 5 ;  → PUSH 5 ; STORE_S id(x)
    यदि (प.वर्तमान.प्रकार == परिचायक) {
      नाम = प.वर्तमान.पाठ्य
      अग्रगामी(&प)
      यदि (प.वर्तमान.प्रकार == सम) {
        अग्रगामी(&प)
        यदि (प.वर्तमान.प्रकार == पूर्णांक) {
          मान = प.वर्तमान.पाठ्य_संख्या
          अग्रगामी(&प)
          यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
          पूर्ण_आदेश(&ल, मान)
          लिख_बाइट(&ल, 0x70)
          आई = दे_आईडी(नाम)
          लिख_i32(&ल, आई)
          जारी
        }
      }
      // यदि केवल नाम ; → LOAD_S नाम ; PRINT (डेमो)
      यदि (प.वर्तमान.प्रकार == विराम) {
        अग्रगामी(&प)
        लिख_बाइट(&ल, 0x71)
        आई = दे_आईडी(नाम)
        लिख_i32(&ल, आई)
        लिख_बाइट(&ल, 0x30)
        जारी
      }
    }
    // जबतक ( i < दीर्घता("…") ) { लिख("*"); i = i + 1; }
    यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "जबतक") {
      // '(' दीर्घता '(' "…" ')' ')' '{' ... '}'
      अग्रगामी(&प)
      अपेक्षित(&प, चिह्न_खुला)
      सीमा = 0
      यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "दीर्घता") {
        अग्रगामी(&प)
        अपेक्षित(&प, चिह्न_खुला)
        यदि (प.वर्तमान.प्रकार == लेख्य) { सीमा = दीर्घता_बाइट(प.वर्तमान.पाठ्य); अग्रगामी(&प) }
        अपेक्षित(&प, चिह्न_बन्द)
      } अन्यथा यदि (प.वर्तमान.प्रकार == पूर्णांक) {
        सीमा = प.वर्तमान.पाठ्य_संख्या; अग्रगामी(&प)
      }
      अपेक्षित(&प, चिह्न_बन्द)

      // कोड उत्पत्ति: काउंटर-स्टैक पद्धति
      // PUSH 0; loop: DUP; PUSH limit; LT; JZ end; BODY; PUSH 1; ADD; JMP loop; end: POP
      पूर्ण_आदेश(&ल, 0)
      लूप_आरम्भ = स्थान(&ल)
      लिख_बाइट(&ल, 0x60)         // DUP
      पूर्ण_आदेश(&ल, सीमा)       // limit
      लिख_बाइट(&ल, 0x40)         // LT
      लिख_बाइट(&ल, 0x51)         // JZ
      जेड_ऑफसेट_स्थान = स्थान(&ल)
      लिख_i32(&ल, 0)             // placeholder

      // शरीर पार्स: '{' ... '}' — अभी केवल लिख("*") और i=i+1 मानते हैं
      अपेक्षित(&प, आकृति_खुली)
      // scan until '}' and emit a print "*"
      लिख्य_आदेश(&ल, "*")
      // इन्क्रीमेंट
      पूर्ण_आदेश(&ल, 1)
      लिख_बाइट(&ल, 0x20)         // ADD
      // जंप बैक
      लिख_बाइट(&ल, 0x50)         // JMP
      जंप_ऑफ_स्थान = स्थान(&ल)
      लिख_i32(&ल, 0)             // placeholder

      अपेक्षित(&प, आकृति_बन्द)

      // पैच ऑफसेट्स
      अंत = स्थान(&ल)
      // JZ offset = end - (after JZ imm)
      जेड_लक्ष्य_ऑफ = (अंत - (जेड_ऑफसेट_स्थान + 4))
      पैच_i32(&ल, जेड_ऑफसेट_स्थान, जेड_लक्ष्य_ऑफ)
      // back jump offset = loop_start - (after JMP imm)
      जंप_लक्ष्य_ऑफ = (लूप_आरम्भ - (जंप_ऑफ_स्थान + 4))
      पैच_i32(&ल, जंप_ऑफ_स्थान, जंप_लक्ष्य_ऑफ)
      // POP counter
      लिख_बाइट(&ल, 0x61)
      जारी
    }
    // योग: संख्या या लेख्य → प्रकार के अनुसार ADD या ADD_S और PRINT
    यदि (प.वर्तमान.प्रकार == पूर्णांक या प.वर्तमान.प्रकार == लेख्य) {
      बाम = प.वर्तमान.पाठ्य_संख्या
      बाम_लेख = प.वर्तमान.प्रकार == लेख्य ? प.वर्तमान.पाठ्य : ""
      अग्रगामी(&प)
      यदि (प.वर्तमान.प्रकार == जोड़) {
        अग्रगामी(&प)
        यदि (प.वर्तमान.प्रकार == पूर्णांक && बाम_लेख == "") {
          दक्षिण = प.वर्तमान.पाठ्य_संख्या
          अग्रगामी(&प)
          यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
          पूर्ण_आदेश(&ल, बाम)
          पूर्ण_आदेश(&ल, दक्षिण)
          लिख_बाइट(&ल, 0x20) // ADD (number)
          लिख_बाइट(&ल, 0x30) // PRINT
          जारी
        } अन्यथा यदि (प.वर्तमान.प्रकार == लेख्य || बाम_लेख != "") {
          दक्षिण_लेख = प.वर्तमान.प्रकार == लेख्य ? प.वर्तमान.पाठ्य : ""
          अग्रगामी(&प)
          यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
          यदि (बाम_लेख == "") { पूर्ण_आदेश(&ल, बाम); लिख_बाइट(&ल, 0x30) /*PRINT*/; } // degrade
          अन्यथा { लेख्य_आदेश(&ल, बाम_लेख) }
          लेख्य_आदेश(&ल, दक्षिण_लेख)
          लिख_बाइट(&ल, 0x24) // ADD_S
          लिख_बाइट(&ल, 0x30) // PRINT
          जारी
        }
      }
    }
    // कार्य परिभाषा: कार्य नाम() { … }
    यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "कार्य") {
      अग्रगामी(&प)
      यदि (प.वर्तमान.प्रकार == परिचायक) {
        कार्यनाम = प.वर्तमान.पाठ्य
        अग्रगामी(&प)
        अपेक्षित(&प, चिह्न_खुला)
        अपेक्षित(&प, चिह्न_बन्द)
        // वैकल्पिक ':' प्रकार को छोड़ें
        यदि (प.वर्तमान.प्रकार == सम) { अग्रगामी(&प); अग्रगामी(&प) }
        अपेक्षित(&प, आकृति_खुली)
        // रिकॉर्ड पता
        कार्य_पते[कार्यनाम] = स्थान(&ल)
        // शरीर—सरलीकृत: लिख("…");, संख्या+संख्या;, असाइन; जबतक दीर्घता("…") { लिख("*"); }
        जबकि (प.वर्तमान.प्रकार != आकृति_बन्द और प.वर्तमान.प्रकार != शब्द_समाप्त) {
          यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "लिख") {
            अग्रगामी(&प)
            अपेक्षित(&प, चिह्न_खुला)
            यदि (प.वर्तमान.प्रकार == लेख्य) { लेख = प.वर्तमान.पाठ्य; अग्रगामी(&प) }
            अपेक्षित(&प, चिह्न_बन्द)
            यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }
            लेख्य_आदेश(&ल, लेख)
            जारी
          }
          यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "जबतक") {
            // उपयोग करें: पूर्व का जबतक ब्लॉक
            // पुन: उपयोग हेतु एक हल्की छलाँग: प.धारा वर्तमान वहीं है; ऊपर का कोड ब्लॉक चला दें
            // (कॉपी-पेस्ट: सरलता के लिए)
            अग्रगामी(&प)
            अपेक्षित(&प, चिह्न_खुला)
            सीमा = 0
            यदि (प.वर्तमान.प्रकार == परिचायक और प.वर्तमान.पाठ्य == "दीर्घता") {
              अग्रगामी(&प)
              अपेक्षित(&प, चिह्न_खुला)
              यदि (प.वर्तमान.प्रकार == लेख्य) { सीमा = दीर्घता_बाइट(प.वर्तमान.पाठ्य); अग्रगामी(&प) }
              अपेक्षित(&प, चिह्न_बन्द)
            } अन्यथा यदि (प.वर्तमान.प्रकार == पूर्णांक) {
              सीमा = प.वर्तमान.पाठ्य_संख्या; अग्रगामी(&प)
            }
            अपेक्षित(&प, चिह्न_बन्द)
            पूर्ण_आदेश(&ल, 0)
            लूप_आरम्भ = स्थान(&ल)
            लिख_बाइट(&ल, 0x60)
            पूर्ण_आदेश(&ल, सीमा)
            लिख_बाइट(&ल, 0x40)
            लिख_बाइट(&ल, 0x51)
            जेड_ऑफसेट_स्थान = स्थान(&ल)
            लिख_i32(&ल, 0)
            अपेक्षित(&प, आकृति_खुली)
            लेख्य_आदेश(&ल, "*")
            पूर्ण_आदेश(&ल, 1)
            लिख_बाइट(&ल, 0x20)
            लिख_बाइट(&ल, 0x50)
            जंप_ऑफ_स्थान = स्थान(&ल)
            लिख_i32(&ल, 0)
            अपेक्षित(&प, आकृति_बन्द)
            अंत = स्थान(&ल)
            जेड_लक्ष्य_ऑफ = (अंत - (जेड_ऑफसेट_स्थान + 4))
            पैच_i32(&ल, जेड_ऑफसेट_स्थान, जेड_लक्ष्य_ऑफ)
            जंप_लक्ष्य_ऑफ = (लूप_आरम्भ - (जंप_ऑफ_स्थान + 4))
            पैच_i32(&ल, जंप_ऑफ_स्थान, जंप_लक्ष्य_ऑफ)
            लिख_बाइट(&ल, 0x61)
            जारी
          }
          // संख्यात्मक योग stmt
          यदि (प.वर्तमान.प्रकार == पूर्णांक) {
            बाम = प.वर्तमान.पाठ्य_संख्या; अग्रगामी(&प)
            यदि (प.वर्तमान.प्रकार == जोड़) { अग्रगामी(&प); यदि (प.वर्तमान.प्रकार == पूर्णांक) { दक्षिण = प.वर्तमान.पाठ्य_संख्या; अग्रगामी(&प); यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }; पूर्ण_आदेश(&ल, बाम); पूर्ण_आदेश(&ल, दक्षिण); लिख_बाइट(&ल, 0x20); लिख_बाइट(&ल, 0x30); जारी } }
          }
          // असाइन/नाम प्रिन्ट: पुन: उपयोग ऊपर जैसा
          यदि (प.वर्तमान.प्रकार == परिचायक) {
            नाम2 = प.वर्तमान.पाठ्य; अग्रगामी(&प)
            यदि (प.वर्तमान.प्रकार == सम) { अग्रगामी(&प); यदि (प.वर्तमान.प्रकार == पूर्णांक) { मान = प.वर्तमान.पाठ्य_संख्या; अग्रगामी(&प); यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प) }; पूर्ण_आदेश(&ल, मान); लिख_बाइट(&ल, 0x70); आई = दे_आईडी(नाम2); लिख_i32(&ल, आई); जारी } }
            यदि (प.वर्तमान.प्रकार == विराम) { अग्रगामी(&प); लिख_बाइट(&ल, 0x71); आई = दे_आईडी(नाम2); लिख_i32(&ल, आई); लिख_बाइट(&ल, 0x30); जारी }
          }
          // अन्यथा आगे बढ़ो
          अग्रगामी(&प)
        }
        अपेक्षित(&प, आकृति_बन्द)
        लिख_बाइट(&ल, 0x81) // RET
        // यदि अभी-अभी 'मुख्य' परिभाषित हुआ, तो उसके पते से प्रारम्भ कॉल पैच करें
        यदि (कार्यनाम == "मुख्य") { पैच_i32(&ल, मुख्य_कॉल_ऑफ, कार्य_पते[कार्यनाम]) }
        जारी
      }
    }
    अग्रगामी(&प)
  }
  लिख_बाइट(&ल, 0x01) // HALT
  // शेष कॉल फिक्सअप
  प्रत्येक (ज, न) में कॉल_फिक्स { यदि (न in कार्य_पते) { पैच_i32(&ल, ज, कार्य_पते[न]) } }
  लौटय ल.कोड
}


